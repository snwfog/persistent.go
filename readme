persistent.go

- lockfree linked-list
- lockfree queue (coming)

motivation

- play with golang pointer and unsafe (gasp!)
- actually need this and benchmark (see below), over a map+mutex, sync.map, or load/store
- other implementations found here were too hard to understand

caveat

- list is actually a set -> duplicate key not allowed
- can be modified to store other struct instead of int (see node struct)

commands

- go generate ./persistent/linked_list

related

- https://github.com/cornelk/go-benchmark
- https://github.com/zond/gotomic
- https://sourcegraph.com/github.com/jserv/concurrent-ll@master

links

- http://www.rossbencina.com/code/lockfree
- http://15418.courses.cs.cmu.edu/spring2013/article/46
- https://preshing.com/20120612/an-introduction-to-lock-free-programming/
- https://en.wikipedia.org/wiki/Non-blocking_algorithm
- https://en.wikipedia.org/wiki/Non-blocking_linked_list

results

- N=5000,M=5000
go test -count=1 -run=XXX -v -benchmem -bench=Campaign ./persistent/campaign_persistent
goos: darwin
goarch: amd64
pkg: persistent.go/persistent/campaign_persistent
BenchmarkCampaignCopyMap-16                               	     500	   2542180 ns/op	 1344221 B/op	     474 allocs/op
BenchmarkCampaignCopyList-16                              	   30000	     42389 ns/op	   24576 B/op	       1 allocs/op
BenchmarkCampaignCopyParallelMap-16                       	    2000	    723699 ns/op	 1344823 B/op	     478 allocs/op
BenchmarkCampaignCopyParallelList-16                      	   50000	     33068 ns/op	   24579 B/op	       1 allocs/op
BenchmarkCampaignCopyParallelMapWithCampaignUpdate-16     	    5000	   1252608 ns/op	 1344272 B/op	     476 allocs/op
BenchmarkCampaignCopyParallelListWithCampaignUpdate-16    	   50000	     31982 ns/op	   24586 B/op	       1 allocs/op
PASS
ok  	persistent.go/persistent/campaign_persistent	31.372s

- using channels
go test -count=1 -run=XXX -v -benchmem -bench=Campaign ./persistent/campaign_persistent
goos: darwin
goarch: amd64
pkg: persistent.go/persistent/campaign_persistent
BenchmarkCampaignCopyMap-16                               	   10000	    162952 ns/op	   86574 B/op	      42 allocs/op
BenchmarkCampaignCopyList-16                              	   30000	     40616 ns/op	   24576 B/op	       1 allocs/op
BenchmarkCampaignCopyParallelMap-16                       	   10000	    102931 ns/op	   99529 B/op	     104 allocs/op
BenchmarkCampaignCopyParallelList-16                      	   50000	     33478 ns/op	   24782 B/op	       7 allocs/op
BenchmarkCampaignCopyParallelMapWithCampaignUpdate-16     	   50000	    109399 ns/op	   86862 B/op	      50 allocs/op
BenchmarkCampaignCopyParallelListWithCampaignUpdate-16    	   30000	     34465 ns/op	   24920 B/op	      11 allocs/op
PASS
ok  	persistent.go/persistent/campaign_persistent	42.593s

- using mutex
go test -count=1 -run=XXX -v -benchmem -bench=CampaignCopy ./persistent/campaign_persistent
goos: darwin
goarch: amd64
pkg: persistent.go/persistent/campaign_persistent
BenchmarkCampaignCopyMap-16                               	   10000	    162923 ns/op	   86584 B/op	      42 allocs/op
BenchmarkCampaignCopyList-16                              	   30000	     39669 ns/op	   24576 B/op	       1 allocs/op
BenchmarkCampaignCopyParallelMap-16                       	   20000	     74198 ns/op	   94000 B/op	      76 allocs/op
BenchmarkCampaignCopyParallelList-16                      	   50000	     34735 ns/op	   24782 B/op	       7 allocs/op
BenchmarkCampaignCopyParallelMapWithCampaignUpdate-16     	   50000	    109837 ns/op	   86864 B/op	      50 allocs/op
BenchmarkCampaignCopyParallelListWithCampaignUpdate-16    	   50000	     34082 ns/op	   24782 B/op	       7 allocs/op
PASS
ok  	persistent.go/persistent/campaign_persistent	41.575s


remarks

- using channel is actually pretty slow
- using mutex most of time is enough
