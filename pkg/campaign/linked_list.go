// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package campaign

import (
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"sync/atomic"
	"unsafe"

	"github.com/dchest/siphash"
)

var (
	inserterr = errors.New("insert failed")
	// deleteerr = errors.New("delete failed")
	// freenode = unsafe.Pointer(new(int))
)

func NewCampaignLinkedList() *linkedlist {
	// head := &sentinel{node{valueptr: -2}}
	// tail := &sentinel{node{valueptr: -1}}
	head := &sentinel{node{}}
	tail := &sentinel{node{}}

	head.next = unsafe.Pointer(tail)
	return &linkedlist{
		head: unsafe.Pointer(head),
		tail: unsafe.Pointer(tail),
	}
}

// region Node
func NewCampaignNode(key interface{}, valueptr *Campaign) *node {
	return &node{
		valueptr: unsafe.Pointer(valueptr),
		key:      getKeyHash(key),
	}
}

func NewBuiltinCampaignNode(value Campaign) *node {
	return NewCampaignNode(value, &value)
}

type node struct {
	key      uint64
	valueptr unsafe.Pointer
	next     unsafe.Pointer // What if GC runs?
}

func (n *node) Next() *node {
	return (*node)(atomic.LoadPointer(&n.next))
}

func (n *node) GetCampaign() *Campaign {
	return (*Campaign)(atomic.LoadPointer(&n.valueptr))
}

func (n *node) GetBuiltinCampaign() Campaign {
	return *(n.GetCampaign())
}

func (n *node) nextptr() unsafe.Pointer {
	return atomic.LoadPointer(&n.next)
}

type sentinel struct {
	node
}

// endregion

// region linkedlist
type linkedlist struct {
	head unsafe.Pointer
	tail unsafe.Pointer

	len int32
}

func (l *linkedlist) Len() int {
	return int(atomic.LoadInt32(&l.len))
}

func (l *linkedlist) Head() *node {
	return (*node)(atomic.LoadPointer(&l.head))
}

func (l *linkedlist) Tail() *node {
	return (*node)(atomic.LoadPointer(&l.tail))
}

func (l *linkedlist) Insert(v *node) (bool, error) {
	var left, right *node
	for {
		left, right = l.search(v.key)

		if right != l.Tail() && right.key == v.key {
			return false, inserterr
		}

		v.next = unsafe.Pointer(right)
		if atomic.CompareAndSwapPointer(&left.next, unsafe.Pointer(right), unsafe.Pointer(v)) {
			atomic.AddInt32(&l.len, 1)
			return true, nil
		}
	}
}

func (l *linkedlist) Upsert(v *node) (bool, error) {
	_, right := l.search(v.key)
	if right != l.Tail() && right.key == v.key {
		atomic.StorePointer(&right.valueptr, v.valueptr)
		return true, nil
	}

	return l.Insert(v)
}

func (l *linkedlist) Delete(v *node) (bool, error) {
	var right *node
	var rightnext unsafe.Pointer

	for {
		_, right = l.search(v.key)
		if right == l.Tail() || right.key != v.key {
			return false, nil // not deleted cause not found
		}

		rightnext = right.nextptr()
		if !marked(rightnext) {
			if atomic.CompareAndSwapPointer(&right.next, rightnext, mark(rightnext)) {
				atomic.AddInt32(&l.len, -1)
				break
			}
		}
	}

	// if !atomic.CompareAndSwapPointer(&left.next, unsafe.Pointer(right), rightnext) {
	//   _, _ = l.search(right.key) // cleanup
	// }

	return true, nil
}

func (l *linkedlist) search(key uint64) (left, right *node) {
	var leftnext *node

	for {
		prev := l.Head()
		currptr := prev.nextptr()

		for {
			if !marked(currptr) {
				left = prev
				leftnext = (*node)(currptr)
			}

			prev = (*node)(unmark(currptr))
			if prev == l.Tail() {
				break
			}

			currptr = prev.nextptr()
			if !marked(currptr) && prev.key >= key {
				break
			}
		}

		right = prev
		if leftnext == right {
			if right != l.Tail() && marked(right.nextptr()) {
				continue
			}

			return left, right
		}

		if atomic.CompareAndSwapPointer(&left.next, unsafe.Pointer(leftnext), unsafe.Pointer(right)) {
			if right != l.Tail() && marked(right.nextptr()) {
				continue
			}

			return left, right
		}
	}
}

func (l *linkedlist) Contains(n *node) bool {
	_, right := l.search(n.key)
	if right == l.Tail() || right.key != n.key {
		return false
	}

	return true
}

func (l *linkedlist) Iterator() *iterator {
	return NewIterator(l)
}

func (l *linkedlist) CyclicIterator() *cycliciterator {
	return NewCyclicIterator(l)
}

// endregion

// region Iterator
type iterator struct {
	curr *node
	list *linkedlist
}

func NewIterator(list *linkedlist) *iterator {
	return &iterator{
		list: list,
		curr: list.Head(),
	}
}

func (it *iterator) Next() (*node, bool) {
	if it.curr == it.list.Head() {
		it.curr = it.curr.Next()
	}

	for {
		if it.curr == it.list.Tail() {
			return nil, false
		}

		n, nextptr := it.curr, it.curr.nextptr()
		it.curr = (*node)(unmark(nextptr))

		if marked(nextptr) {
			continue
		}

		return n, true
	}
}

// endregion

// region CyclicIterator
type cycliciterator struct {
	iterator
}

func NewCyclicIterator(list *linkedlist) *cycliciterator {
	return &cycliciterator{
		*NewIterator(list),
	}
}

func (it *cycliciterator) Next() (*node, bool) {
	node, ok := it.iterator.Next()

	if !ok {
		it.curr = it.list.Head()
		return it.Next()
	}

	return node, ok
}

// endregion

// region Utilities
const (
	// intSizeBytes is the size in byte of an int or uint value.
	intSizeBytes = strconv.IntSize >> 3

	// generated by splitting the md5 sum of "hashmap"
	sipHashKey1 = 0xdda7806a4847ec61
	sipHashKey2 = 0xb5940c2623a5aabd
)

func getKeyHash(key interface{}) uint64 {
	switch x := key.(type) {
	case string:
		return getStringHash(x)
	case []byte:
		return siphash.Hash(sipHashKey1, sipHashKey2, x)
	case int:
		return getUintptrHash(uintptr(x))
	case int8:
		return getUintptrHash(uintptr(x))
	case int16:
		return getUintptrHash(uintptr(x))
	case int32:
		return getUintptrHash(uintptr(x))
	case int64:
		return getUintptrHash(uintptr(x))
	case uint:
		return getUintptrHash(uintptr(x))
	case uint8:
		return getUintptrHash(uintptr(x))
	case uint16:
		return getUintptrHash(uintptr(x))
	case uint32:
		return getUintptrHash(uintptr(x))
	case uint64:
		return getUintptrHash(uintptr(x))
	case uintptr:
		return getUintptrHash(x)
	}
	panic(fmt.Errorf("unsupported key type %TH", key))
}

func getStringHash(s string) uint64 {
	sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
	bh := reflect.SliceHeader{
		Data: sh.Data,
		Len:  sh.Len,
		Cap:  sh.Len,
	}
	buf := *(*[]byte)(unsafe.Pointer(&bh))
	return siphash.Hash(sipHashKey1, sipHashKey2, buf)
}

func getUintptrHash(num uintptr) uint64 {
	bh := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&num)),
		Len:  intSizeBytes,
		Cap:  intSizeBytes,
	}
	buf := *(*[]byte)(unsafe.Pointer(&bh))
	return siphash.Hash(sipHashKey1, sipHashKey2, buf)
}

// func use(params ...interface{}) {
// 	for _, val := range params {
// 		_ = val
// 	}
// }

func marked(ptr unsafe.Pointer) bool {
	return (uintptr(ptr) & 0x1) > 0
}

func mark(ptr unsafe.Pointer) unsafe.Pointer {
	return unsafe.Pointer(uintptr(ptr) | 0x1)
}

func unmark(ptr unsafe.Pointer) unsafe.Pointer {
	return unsafe.Pointer(uintptr(ptr) &^ 0x1)
}
